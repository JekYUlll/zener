/*
    在非阻塞网络编程中，如何设计并使用缓冲区？
    1.一方面我们希望减少系统调用，一次读的数据越多越划算，那么似乎应该准备一个大的缓冲区。
    2.另一方面，我们系统减少内存占用。如果有10k个连接，每个连接一建立就分配64k的读缓冲的话，将占用640M内存，而大多数时候这些缓冲区的使用率很低。
    3.因此读取数据的时候要尽可能读完，为了不扩大buffer，可以通过extrabuf来做第二层缓冲
    4.muduo的解决方案：将读取分散在两块区域，一块是buffer，一块是栈上的extrabuf（放置在栈上使得extrabuf随着Read的结束而释放，不会占用额外空间），当初始的小buffer放不下时才扩容
    */

https://zhuanlan.zhihu.com/p/703329903

/*
    写入空间不够处理方案：
    1.将readable bytes往前移动：因为每次读取数据，readed bytes都会逐渐增大。我们可以将readed bytes直接抛弃，把后面的readable bytes移动到前面prePos处。
    2.如果第一种方案的空间仍然不够，那么就直接对buffer扩容
*/

POST http://www.baidu.com HTTP/1.1                         \r\n       (请求行)
Host: api.efxnow.com                                       \r\n       (一条请求头)
Content-Type: application/x-www-form-urlencoded            \r\n       (一条请求头)
Content-Length: length                                     \r\n       (一条请求头)
                                                           \r\n       (空行)
UserID=string&PWD=string&OrderConfirmation=string                     (请求体)


//   公开密钥加密使用一对非对称的密钥。一把叫做私有密钥（private
//   key），另一把叫做公开密钥（public key）。
// 发送密文的一方使用对方的公开密钥进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密。


/*
 * @Author       : mark
 * @Date         : 2020-06-17
 * @copyleft Apache 2.0
 */ 
#include "heaptimer.h"

void HeapTimer::siftup_(size_t i) {
    assert(i >= 0 && i < heap_.size());
    size_t j = (i - 1) / 2;
    while(j >= 0) {
        if(heap_[j] < heap_[i]) { break; }
        SwapNode_(i, j);
        i = j;
        j = (i - 1) / 2;
    }
}

void HeapTimer::SwapNode_(size_t i, size_t j) {
    assert(i >= 0 && i < heap_.size());
    assert(j >= 0 && j < heap_.size());
    std::swap(heap_[i], heap_[j]);
    ref_[heap_[i].id] = i;
    ref_[heap_[j].id] = j;
} 

bool HeapTimer::siftdown_(size_t index, size_t n) {
    assert(index >= 0 && index < heap_.size());
    assert(n >= 0 && n <= heap_.size());
    size_t i = index;
    size_t j = i * 2 + 1;
    while(j < n) {
        if(j + 1 < n && heap_[j + 1] < heap_[j]) j++;
        if(heap_[i] < heap_[j]) break;
        SwapNode_(i, j);
        i = j;
        j = i * 2 + 1;
    }
    return i > index;
}

void HeapTimer::add(int id, int timeout, const TimeoutCallBack& cb) {
    assert(id >= 0);
    size_t i;
    if(ref_.count(id) == 0) {
        /* 新节点：堆尾插入，调整堆 */
        i = heap_.size();
        ref_[id] = i;
        heap_.push_back({id, Clock::now() + MS(timeout), cb});
        siftup_(i);
    } 
    else {
        /* 已有结点：调整堆 */
        i = ref_[id];
        heap_[i].expires = Clock::now() + MS(timeout);
        heap_[i].cb = cb;
        if(!siftdown_(i, heap_.size())) {
            siftup_(i);
        }
    }
}

void HeapTimer::doWork(int id) {
    /* 删除指定id结点，并触发回调函数 */
    if(heap_.empty() || ref_.count(id) == 0) {
        return;
    }
    size_t i = ref_[id];
    TimerNode node = heap_[i];
    node.cb();
    del_(i);
}

void HeapTimer::del_(size_t index) {
    /* 删除指定位置的结点 */
    assert(!heap_.empty() && index >= 0 && index < heap_.size());
    /* 将要删除的结点换到队尾，然后调整堆 */
    size_t i = index;
    size_t n = heap_.size() - 1;
    assert(i <= n);
    if(i < n) {
        SwapNode_(i, n);
        if(!siftdown_(i, n)) {
            siftup_(i);
        }
    }
    /* 队尾元素删除 */
    ref_.erase(heap_.back().id);
    heap_.pop_back();
}

void HeapTimer::adjust(int id, int timeout) {
    /* 调整指定id的结点 */
    assert(!heap_.empty() && ref_.count(id) > 0);
    heap_[ref_[id]].expires = Clock::now() + MS(timeout);;
    siftdown_(ref_[id], heap_.size());
}

void HeapTimer::tick() {
    /* 清除超时结点 */
    if(heap_.empty()) {
        return;
    }
    while(!heap_.empty()) {
        TimerNode node = heap_.front();
        if(std::chrono::duration_cast<MS>(node.expires - Clock::now()).count() > 0) { 
            break; 
        }
        node.cb();
        pop();
    }
}

void HeapTimer::pop() {
    assert(!heap_.empty());
    del_(0);
}

void HeapTimer::clear() {
    ref_.clear();
    heap_.clear();
}

int HeapTimer::GetNextTick() {
    tick();
    size_t res = -1;
    if(!heap_.empty()) {
        res = std::chrono::duration_cast<MS>(heap_.front().expires - Clock::now()).count();
        if(res < 0) { res = 0; }
    }
    return res;
}

---

https://zhuanlan.zhihu.com/p/622885224

mmap 内存映射实现过程，总的来说可以分为三个阶段：

（一）进程启动映射过程，并在虚拟地址空间中为映射创建虚拟映射区域

1、进程在用户空间调用函数mmap ，原型：void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);

2、在当前进程虚拟地址空间中，寻找一段空闲的满足要求的连续的虚拟地址

3、为此虚拟区分配一个vm_area_struct 结构，接着对这个结构各个区域进行初始化

4、将新建的虚拟区结构（vm_area_struct）插入进程的虚拟地址区域链表或树中

（二）调用内核空间的系统调用函数mmap （不同于用户空间函数），实现文件物理地址和进程虚拟地址的一一映射关系

5、为映射分配新的虚拟地址区域后，通过待映射的文件指针，在文件描述符表中找到对应的文件描述符，通过文件描述符，链接到内核“已打开文集”中该文件结构体，每个文件结构体维护者和这个已经打开文件相关各项信息。

6、通过该文件的文件结构体，链接到file_operations模块，调用内核函数mmap，其原型为：int mmap(struct file *filp, struct vm_area_struct *vma)，不同于用户空间库函数。

7、内核mmap函数通过虚拟文件系统inode模块定位到文件磁盘物理地址。

8、通过remap_pfn_range函数建立页表，即实现了文件地址和虚拟地址区域的映射关系。此时，这片虚拟地址并没有任何数据关联到主存中。

（三）进程发起对这片映射空间的访问，引发缺页异常，实现文件内容到物理内存（主存）的拷贝。

前两个阶段仅在于创建虚拟区间并完成地址映射，但是并没有将任何文件数据拷贝至主存。真正的文件读取是当进程发起读或者写操作时。

9、进程的读写操作访问虚拟地址空间这一段映射地址后，通过查询页表，先这一段地址并不在物理页面。因为目前只建立了映射，真正的硬盘数据还没有拷贝到内存中，因此引发缺页异常。

10、缺页异常进行一系列判断，确定无法操作后，内核发起请求掉页过程。

11、调页过程先在交换缓存空间中寻找需要访问的内存页，，如果没有则调用nopage函数把所缺的页从磁盘装入到主存中。

12、之后进程即可对这片主存进行读或者写的操作了，如果写操作改变了内容，一定时间后系统自动回写脏页面到对应的磁盘地址，也即完成了写入到文件的过程。

注：修改过的脏页面并不会立即更新回文件，而是有一段时间延迟，可以调用msync() 来强制同步，这样所写的内容就能立即保存到文件里了。


---

/*

    场景	实现位置	结果
    模板实现放在头文件	头文件（.h）	所有类型均可正常使用，无链接错误。
    模板实现放在源文件	源文件（.cpp）	仅显式实例化的类型可用，其他类型导致链接错误。
    显式实例化部分类型	源文件（.cpp）	显式实例化的类型可用，其他类型不可用（需提前声明）。
    
*/

进程（Process）：
- 是操作系统进行资源分配和调度的基本单位，是程序的一次运行实例。
- 每个进程有独立的内存空间、文件描述符、栈等资源。
线程（Thread）：
- 是进程中的一个执行单元，是CPU调度的最小单位。
- 同一进程内的线程共享进程的资源（如内存、文件句柄），但拥有独立的栈和程序计数器。

---

原子变量直接使用=赋值时，默认采用顺序一致性内存序（memory_order_seq_cst），即保证操作的全局顺序性和可见性

返回的是一个std::string的临时对象。当调用这个临时对象的c_str()方法时，得到的指针指向该临时对象内部的字符数组。然而，当这个临时对象在表达式结束后被销毁时，其内部的字符数组也会被释放